// Code generated by genx:model DO NOT EDIT.
package v2

import (
	"context"
	"reflect"

	"github.com/xoctopus/x/codex"

	"github.com/xoctopus/sqlx/pkg/builder"
	"github.com/xoctopus/sqlx/pkg/builder/modeled"
	"github.com/xoctopus/sqlx/pkg/errors"
	"github.com/xoctopus/sqlx/pkg/frag"
	"github.com/xoctopus/sqlx/pkg/helper"
	"github.com/xoctopus/sqlx/pkg/session"
	"github.com/xoctopus/sqlx/pkg/types"
	"github.com/xoctopus/sqlx/testdata"
)

var TUser *tUser

func init() {
	m := modeled.M[User]()
	TUser = &tUser{
		Table: m,
		I: iUser{
			Primary:  m.MK("primary"),
			IGender:  m.MK("i_gender"),
			UIUserID: m.MK("ui_user_id"),
			UIName:   m.MK("ui_name"),
		},
		ID:        modeled.CT[User, uint64](m.C("ID")),
		UserID:    modeled.CT[User, testdata.UserID](m.C("UserID")),
		OrgID:     modeled.CT[User, testdata.OrgID](m.C("OrgID")),
		Name:      modeled.CT[User, string](m.C("Name")),
		RealName:  modeled.CT[User, string](m.C("RealName")),
		Age:       modeled.CT[User, int8](m.C("Age")),
		Username:  modeled.CT[User, string](m.C("Username")),
		Nickname:  modeled.CT[User, string](m.C("Nickname")),
		Gender:    modeled.CT[User, testdata.Gender](m.C("Gender")),
		Desc:      modeled.CT[User, string](m.C("Desc")),
		CreatedAt: modeled.CT[User, types.Datetime](m.C("CreatedAt")),
		UpdatedAt: modeled.CT[User, types.Datetime](m.C("UpdatedAt")),
	}
}

// iUser includes all modeled indexes of User
type iUser struct {
	Primary  modeled.Key[User]
	IGender  modeled.Key[User]
	UIUserID modeled.Key[User]
	UIName   modeled.Key[User]
}

// tUser includes modeled table, indexes and column list.
type tUser struct {
	modeled.Table[User]
	I iUser

	ID modeled.TCol[User, uint64]
	// UserID 用户ID
	UserID modeled.TCol[User, testdata.UserID]
	// OrgID 组织ID
	OrgID modeled.TCol[User, testdata.OrgID]
	// Name deprecated to RealName
	Name modeled.TCol[User, string]
	// RealName 用户真实姓名 width changed from 127 to 255
	RealName modeled.TCol[User, string]
	// Age 年龄 datatype changed from int to int8
	Age modeled.TCol[User, int8]
	// Username deprecated
	Username modeled.TCol[User, string]
	// Nickname 用户昵称 deprecated has indexed before
	Nickname modeled.TCol[User, string]
	// Gender 性别 no change
	Gender modeled.TCol[User, testdata.Gender]
	// Desc 描述 new added
	Desc modeled.TCol[User, string]
	// CreatedAt 创建日期时间(毫秒)
	CreatedAt modeled.TCol[User, types.Datetime]
	// UpdatedAt 更新日期时间(毫秒)
	UpdatedAt modeled.TCol[User, types.Datetime]
}

// New creates a new User
func (t *tUser) New() builder.Model {
	return &User{}
}

// AssignmentFor returns assignment by m with expects columns
func (t *tUser) AssignmentFor(m *User, expects ...builder.Col) builder.Assignment {
	cols := t.Pick()
	if len(expects) > 0 {
		cols = builder.ColsOf(expects...)
	}
	vals := make([]any, 0, cols.Len())
	rv := reflect.ValueOf(m).Elem()
	for c := range cols.Cols() {
		if !builder.GetColDef(c).AutoInc {
			vals = append(vals, rv.FieldByName(c.FieldName()).Interface())
		}
	}
	return builder.ColumnsAndValues(cols, vals...)
}

// TableName returns database table name of User
func (m User) TableName() string {
	return "t_user"
}

// TableDesc returns descriptions of User
func (m User) TableDesc() []string {
	return []string{
		"User 用户表V2",
	}
}

// PrimaryKey returns column list of User's primary key
func (m User) PrimaryKey() []string {
	return []string{
		"ID",
	}
}

// Indexes returns index list of User
func (m User) Indexes() map[string][]string {
	return map[string][]string{
		"i_gender": {
			"Gender",
		},
	}
}

// UniqueIndexes returns unique index list of User
func (m User) UniqueIndexes() map[string][]string {
	return map[string][]string{
		"ui_user_id": {
			"UserID",
		},
		"ui_name": {
			"RealName",
		},
	}
}

// Create inserts User to database
func (m *User) Create(ctx context.Context) error {
	m.MarkCreatedAt()
	cols, values := helper.ColumnsAndValuesForInsertion(m)
	_, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Insert().Into(
			TUser,
			builder.Comment("User.Create"),
		).Values(cols, values...),
	)
	return err
}

// List fetch User datalist with condition and additions
func (m *User) List(ctx context.Context, cond builder.SqlCondition, adds builder.Additions, expects ...builder.Col) ([]User, error) {
	cols := frag.Fragment(nil)
	if len(expects) > 0 {
		cols = builder.ColsOf(expects...)
	}
	conds := []frag.Fragment{cond}
	adds = append(
		adds,
		builder.Where(builder.And(conds...)),
		builder.Comment("User.List"),
	)
	rows, err := session.For(ctx, m).Adaptor().Query(
		ctx,
		builder.Select(cols).From(TUser, adds...),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	res := new([]User)
	if err = helper.Scan(ctx, rows, res); err != nil {
		return nil, err
	}
	return *res, nil
}

// FetchByID fetch User by User.ID
func (m *User) FetchByID(ctx context.Context) error {
	conds := []frag.Fragment{
		TUser.ID.AsCond(builder.Eq(m.ID)),
	}
	rows, err := session.For(ctx, m).Adaptor().Query(
		ctx,
		builder.Select(nil).From(
			TUser,
			builder.Where(builder.And(conds...)),
			builder.Limit(1),
			builder.Comment("User.FetchByID"),
		),
	)
	if err != nil {
		return err
	}
	defer rows.Close()
	return helper.Scan(ctx, rows, m)
}

// FetchByUserID fetch User by User.UserID
func (m *User) FetchByUserID(ctx context.Context) error {
	conds := []frag.Fragment{
		TUser.UserID.AsCond(builder.Eq(m.UserID)),
	}
	rows, err := session.For(ctx, m).Adaptor().Query(
		ctx,
		builder.Select(nil).From(
			TUser,
			builder.Where(builder.And(conds...)),
			builder.Limit(1),
			builder.Comment("User.FetchByUserID"),
		),
	)
	if err != nil {
		return err
	}
	defer rows.Close()
	return helper.Scan(ctx, rows, m)
}

// FetchByRealName fetch User by User.RealName
func (m *User) FetchByRealName(ctx context.Context) error {
	conds := []frag.Fragment{
		TUser.RealName.AsCond(builder.Eq(m.RealName)),
	}
	rows, err := session.For(ctx, m).Adaptor().Query(
		ctx,
		builder.Select(nil).From(
			TUser,
			builder.Where(builder.And(conds...)),
			builder.Limit(1),
			builder.Comment("User.FetchByRealName"),
		),
	)
	if err != nil {
		return err
	}
	defer rows.Close()
	return helper.Scan(ctx, rows, m)
}

// UpdateByID update User by User.ID
func (m *User) UpdateByID(ctx context.Context, expects ...builder.Col) error {
	m.MarkModifiedAt()
	conds := []frag.Fragment{
		TUser.ID.AsCond(builder.Eq(m.ID)),
	}
	res, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Update(TUser).
			Set(TUser.AssignmentFor(m, expects...)).
			Where(
				builder.And(conds...),
				builder.Comment("User.UpdateByID"),
			),
	)
	if err != nil {
		return err
	}
	effected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if effected == 0 {
		return codex.New(errors.NOTFOUND)
	}
	return nil
}

// UpdateAndFetchByID update User by User.ID and retrieve record
func (m *User) UpdateAndFetchByID(ctx context.Context, targets ...builder.Col) error {
	return session.For(ctx, m).Adaptor().Tx(
		ctx,
		func(ctx context.Context) error {
			if err := m.UpdateByID(ctx, targets...); err != nil {
				return err
			}
			if err := m.FetchByID(ctx); err != nil {
				return err
			}
			return nil
		},
	)
}

// UpdateByUserID update User by User.UserID
func (m *User) UpdateByUserID(ctx context.Context, expects ...builder.Col) error {
	m.MarkModifiedAt()
	conds := []frag.Fragment{
		TUser.UserID.AsCond(builder.Eq(m.UserID)),
	}
	res, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Update(TUser).
			Set(TUser.AssignmentFor(m, expects...)).
			Where(
				builder.And(conds...),
				builder.Comment("User.UpdateByUserID"),
			),
	)
	if err != nil {
		return err
	}
	effected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if effected == 0 {
		return codex.New(errors.NOTFOUND)
	}
	return nil
}

// UpdateAndFetchByUserID update User by User.UserID and retrieve record
func (m *User) UpdateAndFetchByUserID(ctx context.Context, targets ...builder.Col) error {
	return session.For(ctx, m).Adaptor().Tx(
		ctx,
		func(ctx context.Context) error {
			if err := m.UpdateByUserID(ctx, targets...); err != nil {
				return err
			}
			if err := m.FetchByUserID(ctx); err != nil {
				return err
			}
			return nil
		},
	)
}

// UpdateByRealName update User by User.RealName
func (m *User) UpdateByRealName(ctx context.Context, expects ...builder.Col) error {
	m.MarkModifiedAt()
	conds := []frag.Fragment{
		TUser.RealName.AsCond(builder.Eq(m.RealName)),
	}
	res, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Update(TUser).
			Set(TUser.AssignmentFor(m, expects...)).
			Where(
				builder.And(conds...),
				builder.Comment("User.UpdateByRealName"),
			),
	)
	if err != nil {
		return err
	}
	effected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if effected == 0 {
		return codex.New(errors.NOTFOUND)
	}
	return nil
}

// UpdateAndFetchByRealName update User by User.RealName and retrieve record
func (m *User) UpdateAndFetchByRealName(ctx context.Context, targets ...builder.Col) error {
	return session.For(ctx, m).Adaptor().Tx(
		ctx,
		func(ctx context.Context) error {
			if err := m.UpdateByRealName(ctx, targets...); err != nil {
				return err
			}
			if err := m.FetchByRealName(ctx); err != nil {
				return err
			}
			return nil
		},
	)
}

// DeleteByID delete User recode by User.ID
func (m *User) DeleteByID(ctx context.Context) error {
	conds := []frag.Fragment{
		TUser.ID.AsCond(builder.Eq(m.ID)),
	}
	_, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Delete().From(
			TUser,
			builder.Where(builder.And(conds...)),
			builder.Comment("User.DeleteByID"),
		),
	)
	return err
}

// DeleteByUserID delete User recode by User.UserID
func (m *User) DeleteByUserID(ctx context.Context) error {
	conds := []frag.Fragment{
		TUser.UserID.AsCond(builder.Eq(m.UserID)),
	}
	_, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Delete().From(
			TUser,
			builder.Where(builder.And(conds...)),
			builder.Comment("User.DeleteByUserID"),
		),
	)
	return err
}

// DeleteByRealName delete User recode by User.RealName
func (m *User) DeleteByRealName(ctx context.Context) error {
	conds := []frag.Fragment{
		TUser.RealName.AsCond(builder.Eq(m.RealName)),
	}
	_, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Delete().From(
			TUser,
			builder.Where(builder.And(conds...)),
			builder.Comment("User.DeleteByRealName"),
		),
	)
	return err
}
