// Code generated by genx:model DO NOT EDIT.
package models

import (
	"context"
	"reflect"

	"github.com/xoctopus/x/codex"

	"github.com/xoctopus/sqlx/pkg/builder"
	"github.com/xoctopus/sqlx/pkg/builder/modeled"
	"github.com/xoctopus/sqlx/pkg/errors"
	"github.com/xoctopus/sqlx/pkg/frag"
	"github.com/xoctopus/sqlx/pkg/helper"
	"github.com/xoctopus/sqlx/pkg/session"
	"github.com/xoctopus/sqlx/pkg/types"
	"github.com/xoctopus/sqlx/pkg/types/sqltime"
)

var TOrderSnapshot *tOrderSnapshot

func init() {
	m := modeled.M[OrderSnapshot]()
	TOrderSnapshot = &tOrderSnapshot{
		Table: m,
		I: iOrderSnapshot{
			Primary:      m.MK("primary"),
			IProductName: m.MK("i_product_name"),
			ICreatedAt:   m.MK("i_created_at"),
			UIOrderID:    m.MK("ui_order_id"),
		},
		ID:          modeled.CT[OrderSnapshot, uint64](m.C("ID")),
		OrderID:     modeled.CT[OrderSnapshot, OrderID](m.C("OrderID")),
		ProductID:   modeled.CT[OrderSnapshot, ProductID](m.C("ProductID")),
		ProductSKU:  modeled.CT[OrderSnapshot, string](m.C("ProductSKU")),
		ProductName: modeled.CT[OrderSnapshot, string](m.C("ProductName")),
		Price:       modeled.CT[OrderSnapshot, types.Decimal](m.C("Price")),
		Quantity:    modeled.CT[OrderSnapshot, int64](m.C("Quantity")),
		Subtotal:    modeled.CT[OrderSnapshot, types.Decimal](m.C("Subtotal")),
		CreatedAt:   modeled.CT[OrderSnapshot, sqltime.Timestamp](m.C("CreatedAt")),
	}
	Catalog.Add(TOrderSnapshot)
}

// iOrderSnapshot includes all modeled indexes of OrderSnapshot
type iOrderSnapshot struct {
	Primary      modeled.Key[OrderSnapshot]
	IProductName modeled.Key[OrderSnapshot]
	ICreatedAt   modeled.Key[OrderSnapshot]
	UIOrderID    modeled.Key[OrderSnapshot]
}

// tOrderSnapshot includes modeled table, indexes and column list.
type tOrderSnapshot struct {
	modeled.Table[OrderSnapshot]
	I iOrderSnapshot

	ID modeled.TCol[OrderSnapshot, uint64]
	// @rel Order.OrderID
	OrderID modeled.TCol[OrderSnapshot, OrderID]
	// @rel Product.ProductID
	ProductID modeled.TCol[OrderSnapshot, ProductID]
	// ProductSKU 产品SKU
	ProductSKU modeled.TCol[OrderSnapshot, string]
	// ProductName 产品名称 Product.Name
	ProductName modeled.TCol[OrderSnapshot, string]
	// Price 产品单价 Product.Price
	Price modeled.TCol[OrderSnapshot, types.Decimal]
	// Quantity 订单产品数量
	Quantity modeled.TCol[OrderSnapshot, int64]
	// Subtotal 订单金额
	Subtotal modeled.TCol[OrderSnapshot, types.Decimal]
	// CreatedAt 创建时间 秒时间戳
	CreatedAt modeled.TCol[OrderSnapshot, sqltime.Timestamp]
}

// New creates a new OrderSnapshot
func (t *tOrderSnapshot) New() builder.Model {
	return &OrderSnapshot{}
}

// AssignmentFor returns assignment by m with expects columns
func (t *tOrderSnapshot) AssignmentFor(m *OrderSnapshot, expects ...builder.Col) builder.Assignment {
	cols := t.Pick()
	if len(expects) > 0 {
		cols = builder.ColsOf(expects...)
	}
	vals := make([]any, 0, cols.Len())
	rv := reflect.ValueOf(m).Elem()
	for c := range cols.Cols() {
		if !builder.GetColDef(c).AutoInc {
			vals = append(vals, rv.FieldByName(c.FieldName()).Interface())
		}
	}
	return builder.ColumnsAndValues(cols, vals...)
}

// TableName returns database table name of OrderSnapshot
func (m OrderSnapshot) TableName() string {
	return "t_order_snapshot"
}

// TableDesc returns descriptions of OrderSnapshot
func (m OrderSnapshot) TableDesc() []string {
	return []string{
		"OrderSnapshot 订单快照",
	}
}

// PrimaryKey returns column list of OrderSnapshot's primary key
func (m OrderSnapshot) PrimaryKey() []string {
	return []string{
		"ID",
	}
}

// Indexes returns index list of OrderSnapshot
func (m OrderSnapshot) Indexes() map[string][]string {
	return map[string][]string{
		"i_product_name": {
			"ProductName",
		},
		"i_created_at": {
			"CreatedAt",
		},
	}
}

// UniqueIndexes returns unique index list of OrderSnapshot
func (m OrderSnapshot) UniqueIndexes() map[string][]string {
	return map[string][]string{
		"ui_order_id": {
			"OrderID",
		},
	}
}

// Create inserts OrderSnapshot to database
func (m *OrderSnapshot) Create(ctx context.Context) error {
	m.MarkCreatedAt()
	cols, values := helper.ColumnsAndValuesForInsertion(m)
	_, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Insert().Into(
			TOrderSnapshot,
			builder.Comment("OrderSnapshot.Create"),
		).Values(cols, values...),
	)
	return err
}

// List fetch OrderSnapshot datalist with condition and additions
func (m *OrderSnapshot) List(ctx context.Context, cond builder.SqlCondition, adds builder.Additions, expects ...builder.Col) ([]OrderSnapshot, error) {
	cols := frag.Fragment(nil)
	if len(expects) > 0 {
		cols = builder.ColsOf(expects...)
	}
	conds := []frag.Fragment{cond}
	adds = append(
		adds,
		builder.Where(builder.And(conds...)),
		builder.Comment("OrderSnapshot.List"),
	)
	rows, err := session.For(ctx, m).Adaptor().Query(
		ctx,
		builder.Select(cols).From(TOrderSnapshot, adds...),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	res := new([]OrderSnapshot)
	if err = helper.Scan(ctx, rows, res); err != nil {
		return nil, err
	}
	return *res, nil
}

// FetchByID fetch OrderSnapshot by OrderSnapshot.ID
func (m *OrderSnapshot) FetchByID(ctx context.Context) error {
	conds := []frag.Fragment{
		TOrderSnapshot.ID.AsCond(builder.Eq(m.ID)),
	}
	rows, err := session.For(ctx, m).Adaptor().Query(
		ctx,
		builder.Select(nil).From(
			TOrderSnapshot,
			builder.Where(builder.And(conds...)),
			builder.Limit(1),
			builder.Comment("OrderSnapshot.FetchByID"),
		),
	)
	if err != nil {
		return err
	}
	defer rows.Close()
	return helper.Scan(ctx, rows, m)
}

// FetchByOrderID fetch OrderSnapshot by OrderSnapshot.OrderID
func (m *OrderSnapshot) FetchByOrderID(ctx context.Context) error {
	conds := []frag.Fragment{
		TOrderSnapshot.OrderID.AsCond(builder.Eq(m.OrderID)),
	}
	rows, err := session.For(ctx, m).Adaptor().Query(
		ctx,
		builder.Select(nil).From(
			TOrderSnapshot,
			builder.Where(builder.And(conds...)),
			builder.Limit(1),
			builder.Comment("OrderSnapshot.FetchByOrderID"),
		),
	)
	if err != nil {
		return err
	}
	defer rows.Close()
	return helper.Scan(ctx, rows, m)
}

// UpdateByID update OrderSnapshot by OrderSnapshot.ID
func (m *OrderSnapshot) UpdateByID(ctx context.Context, expects ...builder.Col) error {
	conds := []frag.Fragment{
		TOrderSnapshot.ID.AsCond(builder.Eq(m.ID)),
	}
	res, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Update(TOrderSnapshot).
			Set(TOrderSnapshot.AssignmentFor(m, expects...)).
			Where(
				builder.And(conds...),
				builder.Comment("OrderSnapshot.UpdateByID"),
			),
	)
	if err != nil {
		return err
	}
	effected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if effected == 0 {
		return codex.New(errors.NOTFOUND)
	}
	return nil
}

// UpdateAndFetchByID update OrderSnapshot by OrderSnapshot.ID and retrieve record
func (m *OrderSnapshot) UpdateAndFetchByID(ctx context.Context, targets ...builder.Col) error {
	return session.For(ctx, m).Adaptor().Tx(
		ctx,
		func(ctx context.Context) error {
			if err := m.UpdateByID(ctx, targets...); err != nil {
				return err
			}
			if err := m.FetchByID(ctx); err != nil {
				return err
			}
			return nil
		},
	)
}

// UpdateByOrderID update OrderSnapshot by OrderSnapshot.OrderID
func (m *OrderSnapshot) UpdateByOrderID(ctx context.Context, expects ...builder.Col) error {
	conds := []frag.Fragment{
		TOrderSnapshot.OrderID.AsCond(builder.Eq(m.OrderID)),
	}
	res, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Update(TOrderSnapshot).
			Set(TOrderSnapshot.AssignmentFor(m, expects...)).
			Where(
				builder.And(conds...),
				builder.Comment("OrderSnapshot.UpdateByOrderID"),
			),
	)
	if err != nil {
		return err
	}
	effected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if effected == 0 {
		return codex.New(errors.NOTFOUND)
	}
	return nil
}

// UpdateAndFetchByOrderID update OrderSnapshot by OrderSnapshot.OrderID and retrieve record
func (m *OrderSnapshot) UpdateAndFetchByOrderID(ctx context.Context, targets ...builder.Col) error {
	return session.For(ctx, m).Adaptor().Tx(
		ctx,
		func(ctx context.Context) error {
			if err := m.UpdateByOrderID(ctx, targets...); err != nil {
				return err
			}
			if err := m.FetchByOrderID(ctx); err != nil {
				return err
			}
			return nil
		},
	)
}

// DeleteByID delete OrderSnapshot recode by OrderSnapshot.ID
func (m *OrderSnapshot) DeleteByID(ctx context.Context) error {
	conds := []frag.Fragment{
		TOrderSnapshot.ID.AsCond(builder.Eq(m.ID)),
	}
	_, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Delete().From(
			TOrderSnapshot,
			builder.Where(builder.And(conds...)),
			builder.Comment("OrderSnapshot.DeleteByID"),
		),
	)
	return err
}

// DeleteByOrderID delete OrderSnapshot recode by OrderSnapshot.OrderID
func (m *OrderSnapshot) DeleteByOrderID(ctx context.Context) error {
	conds := []frag.Fragment{
		TOrderSnapshot.OrderID.AsCond(builder.Eq(m.OrderID)),
	}
	_, err := session.For(ctx, m).Adaptor().Exec(
		ctx,
		builder.Delete().From(
			TOrderSnapshot,
			builder.Where(builder.And(conds...)),
			builder.Comment("OrderSnapshot.DeleteByOrderID"),
		),
	)
	return err
}
